#### 1.为何需要?
在实际的游戏开发过程中,往往有当某一模块事件发生时,其他模块要对该事件进行处理的需求。如某一任务完成时,需要通知成就系统来显示成就等。直接在事件发生的代码块
做其他模块应对该事件的逻辑处理,如果需要处理的其他模块过多，那么这段代码的耦合度就会很高,逻辑代码也会陷入混乱。同时一旦该功能完成,需要移除某一个模块应对该
事件的处理也非常棘手。这时我们可以使用观察者模式来实现该功能。它能使代码发出一个消息,并通知对消息感兴趣的对象,而不用关心具体是谁接收到了通知。

#### 2.观察者模式如何工作(实现)的？
##### 观察者(即接收通知的对象)
```cpp
//抽象接口
class Observer{
public:
  virtual ~Observer(){};
  virtual void onNofify(const Entity& entity,Event event) = 0;
};

//具体观察者
class Achievements : public Observer{
public:
    void onNofify(const Entity& entity,Event event) override {
        switch (event) {
            case xxx:
                doSomeThing();
                break;
            default:
                break;
        }
    };
};
```

##### 被观察者(通知方法会被正在被观察的对象调用)  
他有两个职责:1.它拥有观察者的一个列表,这些观察者随时候命接收各种通知。2.发送通知,通知观察者。
```cpp
class Subject{
public:
    //加到监听队列
    void addObserver(Observer* po){};
    //从监听队列移除
    void removeObserver(Observer* po){};

//需要派生事件的类继承该类 onNofify变成保护的函数,只有派生类及其父类可访问
protected:
    void onNofify(const Entity& entity,Event event){
        for (int i = 0; i < numObserver; i++) {
            p_observer[i]->onNofify(entity,event);
        }
    };
    
private:
    //通过一个列表来维护所有的观察者
    Observer* p_observer[MAX_SIZE];
    int numObserver;
}
```

#### 3.面临的问题
1. 运行过慢？  
上述代码实现我们可以看到,对观察者的通知,只是遍历一个列表,调用虚函数进行通知。虚函数对比普通函数会慢一点,但是这种慢在目前的运行环境下可以忽略不计。所有并
不存在运行过慢的问题。
2. 造成阻塞？  
遍历列表对观察者进行通知,所有的观察者都从它们的通知返回后被观察者才能继续工作。所有一旦某一个观察者逻辑出现问题,就会影响被观察者。
3. 动态内存分配  
当游戏运行,我们动态的去添加删除观察者的时候,势必造成维护观察者列表的内存动态分配。这种内存动态分配会造成程序效率的低下。可以考虑通过链表的方式来实现观察者列
表。(责任链模式某种情况下也可)
4. 正确的销毁被观察者和观察者  
可能出现的问题是删除了观察者,但是被观察者列表却还保留着对该观察者的引用。造成内存泄漏。如果避免这种情况发生，最简单的做法是当一个观察者对象被删除时，观察
者本身负责自己从被观察者对象中移除。即在自己的析构方法中添加一个removeObserver的函数即可。
5. 小心GC陷阱  
有一个显示血条的UI界面,当玩家进入的时候会创建一个UI实例。当玩家关闭该界面,可以忽略该对象交给垃圾收集器处理。但是假如该界面有一个观察者对象呢？在关闭界面没
有注销该观察者。那么每次打开界面都会创建一个新UI实例,并将一个新的观察者加入到新的监听列表。由于观察者没有正确析构,保持了对UI实例的引用，因此垃圾收集器也不会释放该UI实例。从而导
致了一些僵尸UI在内存中。为了避免这种失效观察者的问题，我们要及时删除观察者。
